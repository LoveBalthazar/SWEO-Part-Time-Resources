// Double Sequence
// Write a function doubleSequence that accepts a base and a length as
// arguments. The function should return an array representing a sequence that contains
// "length" elements. The first element of the sequence is always the "base",
// the subsequent elements can be generated by doubling the previous
// element of the sequence.


// Your code here

// will return an array
// the array that we will be returning will be "length" long
// doubling each number for each iteration
// we would be using a for loop or a while loop

let doubleSequence = function(base, length){
	let result = [base];

	if(length === 0){
		return [];
	}

	// for(let i = 0; i < length - 1; i++){
	// 	let currentNumber = result[i]
	// 	currentNumber *= 2
	// 	result.push(currentNumber)
	// }
	helperDouble(result, length)

	return result
}

let helperDouble = function(result, length){
	for(let i = 0; i < length - 1; i++){
		let currentNumber = result[i]
		currentNumber *= 2
		result.push(currentNumber)
	}
}

// console.log(doubleSequence(7, 3));  // [7, 14, 28]
// console.log(doubleSequence(3, 5));  // [3, 6, 12, 24, 48]
// console.log(doubleSequence(5, 3));  // [5, 10, 20]
// console.log(doubleSequence(5, 4));  // [5, 10, 20, 40]
// console.log(doubleSequence(5, 0));  // [ ]


// Pair Product
// Write a function pairProduct that accepts an array of numbers
// and a product as arguments. The function should return a boolean
// indicating whether or not a pair of distinct elements in the
// array result in the product when multiplied together.
// You may assume that the input array contains unique elements.


// first argument is going to be an array
// second would be a product
// where going to iterate through an array
// should a boolean (true/false)
// unique elements
// pair would be distinct
// we can use nested loops in finding unique pairs
// we will need a conditional to check wether pair1 * pair2 === product

// your code here

let pairProduct = function(array, product){
	for(let i = 0; i < array.length; i++){ // i = 0; num1 = 4
		let num1 = array[i]
		for(let j = i + 1; j < array.length; j++){ // j = 1; num2 = 2; j = 2; num2 = 5 ...
			let num2 = array[j]
			if(ifEquals(num1, num2, product)){
				return true
			}
		}
	}
	return false
}

let ifEquals = function(num1, num2, product){
	if(num1 * num2 === product){
		return true
	}
	return false
}


// console.log(pairProduct([4, 2, 5, 8], 16))    // true
// console.log(pairProduct([8, 1, 9, 3], 8))     // true
// console.log(pairProduct([3, 4], 12))          // true
// console.log(pairProduct([3, 4, 6, 2, 5], 12)) // true
// console.log(pairProduct([4, 2, 5, 7], 16))    // false
// console.log(pairProduct([8, 4, 9, 3], 8))     // false
// console.log(pairProduct([3], 12))             // false


// Snake to Camel
// Write a function snakeToCamel that takes in a
// snake_cased string and returns a PascalCased
// version of the string. snakecase is
// where each word is separated with underscores (`_`).
// PascalCase is a string where the first char of
// each word is capital, all other chars lowercase.


// we know we are getting a string
// return a new string
// we can use split(' ') each word by spaces but in this case we can use split('_')
// we can use indexing and slicing
// if we do string[0] we can access the first character
// if we string.slice(1)

// Your code here

let snakeToCamel = function(string){
	let words = string.split('_'); // ['snakes', 'go', 'hiss']
	let newWords = '';

	for(let i = 0; i < words.length; i++){
		let word = words[i];
		let newWord = word[0].toUpperCase() + word.slice(1).toLowerCase()
		newWords += newWord
	}

	return newWords
}


// console.log(snakeToCamel('snakes_go_hiss')); // 'SnakesGoHiss'
// console.log(snakeToCamel('say_hello_world')); // 'SayHelloWorld'
// console.log(snakeToCamel('app_academy_is_cool')); // 'AppAcademyIsCool'
// console.log(snakeToCamel('APp_ACADEMY_iS_cOol')); // 'AppAcademyIsCool'


// Strange Sums
// Write a function strangeSums that accepts an
// array of numbers as an argument. The method should
// return a count of the number of distinct pairs of
// elements that have a sum of zero.
// You may assume that the input array contains unique elements.

// we know we are getting an array so therefore we have to loop/iterate
// return a count
// we have conditional that checks if num1 + num2 === 0
// unique elements
// distinct pairs

// your code here

let strangeSums = function(array){
	let count = 0;
	for(let i = 0; i < array.length; i++){
		let num1 = array[i];
		for(let j = i+1; j < array.length; j++){
			// let num2 = array[j];
			// if(num1 + num2 === 0){
			// 	count++
			// }
			count = helper(array, count, j, num1) // we are reassigning our count
		}
	}
	return count
}

let helper = function(array, count, j, num1){
	let num2 = array[j];
	if(num1 + num2 === 0){
		count++
	}
	return count // where returning because number is not immutable
}


// console.log(strangeSums([2, -3, 3, 4, -2]));     // 2
// console.log(strangeSums([42, 3, -1, -42]));      // 1
// console.log(strangeSums([-5, 5]));               // 1
// console.log(strangeSums([19, 6, -3, -20]));      // 0
// console.log(strangeSums([9]));                   // 0


// Three Increasing
// Write a function threeIncreasing that accepts
// an array of numbers as an argument.
// The function should return a boolean
// indicating whether or not the array contains
// three consecutive numbers in consecutive increasing order,
// like 7, 8, 9.


// Your code here



// console.log(threeIncreasing([3, 2, 11, 12, 13, 2, 4]));     // true
// console.log(threeIncreasing([2, 7, 8, 9]));                 // true
// console.log(threeIncreasing([7, 2, 4, 5, 2, 1, 6]));        // false
// console.log(threeIncreasing([1, 2, 4, 5, 2, 7, 8]));        // false


// Unique
// Write a function unique that accepts an array as an argument.
// The function should return a new array containing elements of the
// input array, without duplicates.

// we are getting array so therefore we are iterating through array
// we are returning new array
// we can use the includes method to check if a value already exist within an array
// includes returns true/false
// we have to use a conditonal

// Your code here

let unique = function(array){
	let uniques = [];

	for(let i = 0; i < array.length; i++){
		let char = array[i]
		if(!uniques.includes(char)){
			uniques.push(char)
		}
	}

	return uniques
}



// console.log(unique([1, 1, 2, 3, 3])); // [1, 2, 3]
// console.log(unique([11, 7, 8, 10, 8, 7, 7])); // [11, 7, 8, 10]
// console.log(unique(['a', 'b', 'c', 'b'])); // ['a', 'b', 'c']


// Zany Zip
// Write a function zanyZip that accepts
// two arrays as arguments. The function should return a
// two dimensional array with subarrays of length 2
// that contain elements at corresponding indices from
// the input arrays. If one of the arrays is shorter
// than the other, then substitute null for the missing elements.

// we are getting 2 arrays
// returns a 2 dimensional array
// Subarrays within the array are of length 2
// we have a conditional to check if an element is missing
// then we replace with null
// we should be iterating through each of these arrays
// since 2 arrays can have different lengths
// we choose one with the greatest length as a our condition for the loop
// we have conditonals to check which length is the greatest

// Your code here



// console.log(zanyZip([1, 2], ['eins', 'zwei', 'drei', 'vier']));
// // [ [ 1, 'eins' ], [ 2, 'zwei' ], [ null, 'drei' ], [ null, 'vier' ] ]

// console.log(zanyZip([1, 2, 3, 4], ['eins', 'zwei', 'drei']));
// // [ [ 1, 'eins' ], [ 2, 'zwei' ], [ 3, 'drei' ], [ 4, null ] ]

// console.log(zanyZip(['alef', 'bet'], ['alpha', 'beta']));
// // [ [ 'alef', 'alpha' ], [ 'bet', 'beta' ] ]


// Spiral Matrix (*)
// Write a function spiralOrder(matrix)
// that takes in a 2-dimensional array (matrix)
// and returns an array containing the elements in spiral order.


// array.pop()
// array.push()
// array.shift()
// array.unshift()

// array.slice()
// array.splice()

// remove the elements in a spiral approach
// repeat same approach
// each individual removed element add onto new array
// return that new array

let spiralOrder = function(matrix){
	let newArray = [];

	while(matrix.length){ // this while will stop when the length of the matrix is 0

		// first we wanna remove the first array
		let firstRow = matrix.shift(); // removes the first array

		for(let i = 0; i < firstRow.length; i++){
			let currentElement = firstRow[i];
			newArray.push(currentElement)
		}

		// console.log(newArray)
		// second we wanna remove the last elements of the array
		for(let i = 0; i < matrix.length; i++){
			let currentRow = matrix[i]
			let poppedElement = currentRow.pop();
			newArray.push(poppedElement)
		}

		// third we wanna remove the last array's elements in reverse order
		if(matrix.length){
			let lastRow = matrix.pop();
			// console.log(lastRow, ' last row')
			let lastRowLength = lastRow.length

			for(let i = 0; i < lastRowLength; i++){
				let poppedElement = lastRow.pop()
				newArray.push(poppedElement)
			}
		}

		// fourth we wanna remove the remaining first elements from bottom to up
		let matrixLength = matrix.length; // 1
		for(let i = matrixLength - 1; i >= 0; i--){
			let currentRow = matrix[i]
			let shiftedElement = currentRow.shift();
			newArray.push(shiftedElement)
		}

		// repeat
	}

	return newArray;
}

matrix = [[ 1, 2, 3],
          [ 4, 5, 6],
          [ 7, 8, 9]]

console.log(spiralOrder(matrix)); // [1,2,3,6,9,8,7,4,5]

matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9,10,11,12]]

console.log(spiralOrder(matrix)); // [1,2,3,4,8,12,11,10,9,5,6,7]

matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9,10,11,12],
		  [13,14,15,16]]

console.log(spiralOrder(matrix)); //
